//@version=5
//@strategy_alert_message {{strategy.order.alert_message}}
import dokang/POA/12 as POA
password = "1q2w3e4r%t"

// 시작시간, 종료시간 설정
start_time = input.time(timestamp("2023-10-11T18:26:00+09:00"), title="자동매매 시작")
end_time = input.time(timestamp("2024-09-19T21:31:00+09:00"), title="자동매매 종료")

in_trade = POA.in_trade(start_time, end_time)
bgcolor(in_trade ? color.rgb(83, 107, 173, 94) : na)


strategy("다이버전스 전략",
 overlay = false,
 process_orders_on_close = true,
 initial_capital = 100,
 default_qty_type = strategy.fixed, 
 default_qty_value = 0.001)

//1. 지표
overBuy = 50//70 //과매수
overSell = 50//30 //과매도
h1 = hline(70)//hline(overBuy)
h2 = hline(30)//hline(overSell)

// fill 기능
fill( h1,h2, color=color.new(color.purple, 90))
rsi = ta.rsi( close, 14)
plot( rsi, linewidth = 2)

//2. 피봇 찾기 ( 상승 div- 피봇 로우, 하락div )
pivotlow = ta.pivotlow(rsi, 5, 5)
pivothigh = ta.pivothigh(rsi, 5, 5) 
plot( pivotlow, color = color.green, linewidth=3 , style=plot.style_linebr, offset = -5) //저점마다 그린 점이 찍힘. plot.style_linebr : 값이 없는곳은 안 그려짐.
plot( pivothigh, color = color.rgb(228, 22, 81), linewidth=3 , style=plot.style_linebr, offset = -5) //저점마다 그린 점이 찍힘.

//3. 다이버전스 찾기

// regular 상승다이버전스 ==> 지표 피봇저점은 상승, 가격 저점은 하락
prev_pivotlow = ta.valuewhen(pivotlow, pivotlow, 1) // pivotlow 가 있으면 pivotlow를 가져올꺼다,, 1개 전의 pivotlow
osc_higher_low = pivotlow ? pivotlow > prev_pivotlow: false
isUnderSell = pivotlow < overSell // 과매도 값은 30 인데,, pivotlow라는값은 rsi값이므로 0 ~ 100 사이의 값임.
bgcolor( osc_higher_low ? color.rgb(76, 175, 79, 90) : na, offset = -5 )

prev_low = ta.valuewhen(pivotlow, low[5], 1)
//price_lower_low = pivotlow ? 가격의 저점은 하락 : false
price_lower_low = pivotlow ? low[5] < prev_low : false
bgcolor( price_lower_low ? color.rgb(255,153,0,90) : na, offset = -5)

is_regular_bullish_divergence = osc_higher_low and price_lower_low and isUnderSell
//bgcolor( is_regular_bullish_divergence ?  color.green: na, offset = -5)

plotshape( is_regular_bullish_divergence ? pivotlow : na , offset = -5 , title="상승 다이버전스", text = 'Bull', style= shape.labelup, color = color.green,textcolor = color.white, location = location.absolute ) 
plot( pivotlow ? pivotlow : na, color = is_regular_bullish_divergence ? color.green : na , offset = -5 , linewidth= 2)


// regular 하락다이버전스 ==> 지표 피봇고점은 하락, 가격 고점은 상승
prev_pivothigh = ta.valuewhen(pivothigh , pivothigh, 1)
osc_lower_high = pivothigh ? pivothigh < prev_pivothigh : false
isOverBuy = pivothigh > overBuy // pivothigh는 0 ~ 100 사이에 있는 rsi값임. ,, overBuy 는 80같은 값
bgcolor( osc_lower_high ? color.rgb(76, 175, 79, 90) : na, offset = -5 )

prev_high = ta.valuewhen( pivothigh, high[5], 1 )
price_higher_high = pivothigh ? high[5] > prev_high : false

is_regular_bearish_divergence = osc_lower_high and price_higher_high and isOverBuy
//bgcolor( is_regular_bearish_divergence ? color.red : na , offset = -5 )

plotshape( is_regular_bearish_divergence ? pivothigh : na , offset = -5 , title="하락 다이버전스", text = 'Bear', style= shape.labelup, color = color.red,textcolor = color.white, location = location.absolute ) 
plot( pivothigh ? pivothigh : na, color = is_regular_bearish_divergence ? color.red : na , offset = -5 , linewidth= 2)


//4. 전략 진입 | 종료

// 오픈된 포지션이 있을때에만 가장 최근의 entry_bar_index 표시
//recent_entry_bar_index = strategy.opentrades > 0 ? strategy.opentrades.entry_bar_index(strategy.opentrades-1) : na
//label.new(recent_entry_bar_index, na, "entry_index", color= color.white, style=label.style_label_up ,yloc=yloc.belowbar ,size=size.small,tooltip=str.tostring(recent_entry_bar_index))


//진입시점의 저가를 알기 위해                       // 현재 bar_index로부터 가장 최근의 entry_bar_index 뺀 결과
barsSinceRecentEntry = strategy.opentrades > 0 ?  bar_index - strategy.opentrades.entry_bar_index(strategy.opentrades-1) : na
//label.new(time, na, str.tostring(barsSinceRecentEntry), color= color.purple, textcolor = color.white, style=label.style_label_up ,xloc=xloc.bar_time,yloc=yloc.belowbar ,size=size.small)
//plot(barsSinceRecentEntry? low[barsSinceRecentEntry] : na, linewidth=2, color=color.yellow, style=plot.style_linebr)
///end of 진입시의 저가 low[barsSinceRecentEntry]

// 롱 트레일링 스탑
long_trail_percent = input.float(2.0, "롱 트레일")/100
long_stop_price = 0.0 // 롱스탑 프라이스 초기화 .


is_long = is_regular_bullish_divergence   

if in_trade                                        // 현재 포지션에 진입되어 있는지 확인
    if( is_long and strategy.position_size == 0 ) // strategy.position_size > 0 롱포지션 진입 중 , strategy.position_size < 0 숏포지션 진입 중
        strategy.entry( "롱", strategy.long, alert_message = POA.entry_message(password))
        strategy.exit("스탑","롱", stop= close * ( 1- long_trail_percent ) )

is_long_close = false
if( is_regular_bearish_divergence ) // 하락다이버전스가 뜨던가,
    is_long_close := true
//if( low[barsSinceRecentEntry] > low + 100 ) // 아니면 진입시점의 가격보다 현재 저가가 100을 빼고도 작을경우 ( 손절 )
//    is_long_close := true
//if( low[barsSinceRecentEntry] < low - 500 ) // 아니면 진입시점의 가격보다 현재 저가가 1000 이상 커진경우 ( 익절 )   
//    is_long_close := true

if in_trade
    if( is_long_close )
        strategy.close( "롱", comment = "롱 종료", alert_message = POA.close_message(password))

// 트레일링 스탑 ( 익절도 되고 손절도 됨. )
if strategy.position_size > 0 // 롱 포지션이 있으면 2% 밑에서 계속 stop value가 계산됨.
    stop_value = close * ( 1- long_trail_percent )
    long_stop_price := math.max( stop_value, long_stop_price[1] ) // 내가 이전에 계산해 놨던 long stop proce를 가져와서 비교하여 max저장.
else 
    long_stop_price := 0.0 // 롱 스탑 을 무력화.

if strategy.position_size > 0  // 계속 stop주문은 변경이 된다. 
    strategy.exit("스탑", "롱", stop= long_stop_price )

plot( strategy.position_size > 0 ? long_stop_price : na , style= plot.style_linebr, color=color.green, linewidth=2) // 롱스탑값이 없으면 안그리고 있을 때 그림.
// End of 트레일링 스탑

///////////

//////////         SHORT 
//////////

// 숏 트레일링 스탑
short_trail_percent = input.float(2.0, "숏 트레일")/100
short_stop_price = 99999.9 // 숏스탑 프라이스 초기화 .


is_short = is_regular_bearish_divergence   

if in_trade
    if( is_short and strategy.position_size == 0)
        strategy.entry( "숏", strategy.short, alert_message = POA.entry_message(password))
        strategy.exit("스탑", "숏", stop= close * ( 1 + short_trail_percent) )

is_short_close = false
if( is_regular_bullish_divergence ) // 상승다이버전스가 뜨던가,
    is_short_close :=  true
//if( high[barsSinceRecentEntry] < high - 100 ) // 아니면 진입시점의 가격보다 현재 고가가 100을 더해도 큰경우 ( 손절 )
//    is_short_close :=  true
//if( high[barsSinceRecentEntry] > high + 500  ) // 아니면 진입시점의 가격보다 현재 저가가 100을 빼고도 작을경우 ( 익절 )
//    is_short_close :=  true
     

//  숏 포지션 정리.
if in_trade
    if( is_short_close )
        strategy.close( "숏", comment = "숏 종료",  alert_message = POA.close_message(password))

// 트레일링 스탑
if strategy.position_size < 0 // 숏 포지션이 있으면 2% 위에서 계속 stop value가 계산됨.
    stop_value = close * ( 1 + short_trail_percent )
    short_stop_price := math.min( stop_value, short_stop_price[1] ) // 내가 이전에 계산해 놨던 long stop proce를 가져와서 비교하여 max저장.
else 
    short_stop_price := 99999.9 // 숏 스탑 을 무력화.

if strategy.position_size < 0  // 숏 포지션이 존재할 때만 stop주문을 넣는다. 
    strategy.exit("스탑", "숏", stop= short_stop_price )

plot( strategy.position_size < 0 ? short_stop_price : na , style= plot.style_linebr, color=color.red, linewidth=2) // 롱스탑값이 없으면 안그리고 있을 때 그림.
// End of 트레일링 스탑


// close : 시장가 종료
// exit : 지정가 종료

// stratege.exit( "종료", "롱", stop=stratege.position_avg_price * 0.9 , limit= stratege.position_avg_price *1.1 )